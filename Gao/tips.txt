本地创建ssh key
ssh-keygen -t rsa -C "your_email@youremail.com"
git hub增加ssh key

设置username email
设置username emailgit config --global user.name "your name"
git config --global user.email "your_email@youremail.com"

git clone从现有Git仓库拷贝项目
git clone git@github.com:Suyiwei9527/Python_case_100.git

本地仓库由working dir、Index、HEAD组成

提出更改（添加到暂存区）
git add <filename>
git add *
实际提交改动（提交到HEAD）
git commit -m 'add syn-syn time diff script'
提交到远端仓库
git push origin main

未克隆现有仓库
git remote add origin <server>
origin：远程仓库的名称

创建feature_x分支
git checkout -b feature_x
切回主分支
git checkout master
删除feature_x分支
git checkout -d feature_x

更新本地仓库至最新（工作目录中获取并合并远端改动）
git pull
变基
git pull --rebase

HEAD中的最新内容替换掉你的工作目录filename，已添加到暂存区的改动以及新文件都不会受到影响。
git checkout -- <filename>
 
丢弃本地所有改动与提交
git fetch origin（从服务器上获取最新版本）
git reset --hard origin/main

PVWJZBHLVZCVCYJM
负数 在计算机中以补码形式存储

return
datetime.timedelta(days=1) 返回操作后的日期
使用join链接list成为字符串
“”.join(k for k in l)
spilt 将一个字符串分割成多个元素的list
reduce(function, iterable[, initializer]) 将iterable可迭代对象进行function操作
(?:x) 匹配x后当做整体处理，非捕获括号
sorted(iterable, key=None, reverse=False) 可迭代对象iterable，以key进行比较排序，最终返回一个新list
定义可变参数，在参数前面加了一个*号	def calc(*numbers):
在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
关键字参数允许传入0个或任意个含参数名的参数，在函数内部自动组装为一个dict	def person(name, age, **kw):
dict前面加**号，把dict的所有key-value用关键字参数传入到函数的**kw参数，kw将获得一个dict
def person(name, age, *, city, job):	*后面的参数被视为命名关键字参数
socket.inet_ntoa(struct.pack(">I",random.randint(2164260864,3741648133)))：随机int打包成大端存储无符号四字节整数字节序----->IP地址的标准点号分隔字符串

time.time() 返回当前时间的时间戳（1970纪元后经过的浮点秒数
time.ctime 时间戳（按秒计算的浮点数）转化为time.asctime()的形式
time.asctime 接受时间元组并返回一个可读的形式为"Tue Dec 11 18:07:14 2008"（2008年12月11日 周二18时07分14秒）的24个字符的字符串
time.localtime 函数类似gmtime()，作用是格式化时间戳为本地的时间
time.gmtime 函数将一个时间戳转换为UTC时区（0时区）的struct_time

time.strptime() 根据指定格式，把一个时间字符串解析为时间元组,获取结构化时间
time.mktime() 根据结构时间，获取时间戳
time.strftime() 根据结构时间，获取指定格式时间

datetime 重新封装了time模块，提供的类有 date time datetime timedelta tzinfo
date:
date.max、date.min：date对象所能表示的最大、最小日期；
date.resolution：date对象表示日期的最小单位。这里是天
date.today() 返回一个表示当前本地日期的date对象
date.formtimestamp(timestamp) 根据给定的时间戮，返回一个date对象
datetime:
datetime.today()：返回一个表示当前本地时间的datetime对象
datetime.now([tz])：返回一个表示当前本地时间的datetime对象，如果提供了参数tz，则获取tz参数所指时区的本地时间
datetime.utcnow()：返回一个当前utc时间的datetime对象；#格林威治时间
datetime.fromtimestamp(timestamp[, tz])：根据时间戮创建一个datetime对象，参数tz指定时区信息
datetime.utcfromtimestamp(timestamp)：根据时间戮创建一个datetime对象
datetime.combine(date, time)：根据date和time，创建一个datetime对象
datetime.strptime(date_string, format)：将格式字符串转换为datetime对象
timedelta 在日期上做天days，小时hour，分钟，秒，毫秒，微妙的时间计算

os.listdir(path) 返回指定的文件夹包含的文件或文件夹的名字的列表

主机序字节指小端存储，低位字节在内存的低地址端
网络序字节指大端存储，低位字节在内存的高地址端

Socket
socket.ntohl(x)：32位正整数网络序----->主机字节序
socket.ntohs(x)：16位正整数网络序----->主机字节序
socket.htonl(x)：32位正整数主机字节序----->网络序
socket.htons(x)：16位位正整数主机字节序----->网络序
socket.inet_aton(ip_string)：IPV4地址字符串（192.168.10.8）----->32位打包的二进制格式（长度为4个字节的二进制字符串）
socket.inet_ntoa(packed_ip)：32位打包的IPV4地址----->IP地址的标准点号分隔字符串
socket.inet_pton(address_family,ip_string)：IP地址字符串----->打包二进制格式。AF_INET和AF_INET6分别表示IPV4和IPV6
socket.inet_ntop(address_family,packed_ip)：打包IP地址----->标准字符串表达式

struct解决bytes和其他二进制数据类型转换
struct.pack：任意数据类型----->bytes
struct.pack('>I', 10240099)    >表示字节顺序是big-endian    I表示4字节无符号整数
struct.unpack：bytes----->相应的数据类型

迭代：通过重复执行特定步骤逼近目标的过程，循环结构
递归：调用自身，将问题分解为相似子问题来求解，分治问题

字符串最常用数据类型
字符串格式化：将值插入到一个有字符串格式符%s的字符串中
%s %d %c %p %u
str.format() 增强了字符串格式化的功能
f-string字面量格式化字符串
name = 'Runoob'
f'Hello {name}'  # 替换变量
'Hello Runoob'

序列是最基本的数据结构，共6个序列的内置类型
list:数据类型
append()更新、pop()删除并返回、del语句删除、列表可嵌套，operator模块的eq方法用于比较
len(list)、min(list)、max（list）、list(seq)函数

元组与list类似，但不能修改，指元组指向内存中的内容不可变
tuple(iterable)函数：可迭代系列转换为元组
元组推导式是用()圆括号，返回的结果是一个生成器对象，tuple()函数可将其转换成元组


dict：可变容器模型，且可存储任意类型对象
1.不允许同一个键出现两次
2.键必须不可变
dict.copy()
直接赋值是引用对象，随着原始对象变化；浅拷贝（一级目录深拷贝，二级目录引用)；深拷贝需引入copy模块，完全拷贝父、子对象

set：无序的不重复元素序列
创建一个空集合必须用set()，因为{ }是用来创建一个空字典
集合推导式(Set comprehension):
a = {x for x in 'abracadabra' if x not in 'abc'}
{'r', 'd'}

迭代器有两个基本方法：iter() 和 next()。

使用了yield的函数称为生成器

面向对象：
Class：相同属性和方法的对象的集合，对象是类的实例；定义了对象的结构和行为
方法：类中定义的函数
方法重写：父类继承的方法不满足子类需求，可以进行改写
局部变量：定义在方法中的变量，只作用于当前实例的类
实例变量（实例属性）：通过 self.变量名 在 __init__ 或其他实例方法中定义‌；在类的声明中，属性（用self修饰的变量）是用变量来表示的
类变量（类属性）：直接在类中定义；属于类本身，所有实例共享同一个值；
对象：通过类定义的数据结构的实例包括（类变量、实例变量）和方法
__init__是类的构造函数，类实例化时会自动调用 __init__() 的特殊方法：为对象初始化属性或执行必要的设置操作（定义对象的初始状态）
未显式定义 __init__，Python 会提供默认的空构造函数（不执行任何操作）
self代表类的实例（对象），而非类
通过self.属性名 绑定实例属性，使数据与对象生命周期绑定

super() 函数用于调用父类已被覆盖的方法

关键字end可以用于将结果输出到同一行，或者在输出的末尾添加不同的字符

_name_ 是一个内置变量，表示当前模块的名称
主程序时为"__main__"，被当模块导入时为模块的文件名

变量没有类型，是一个对象的引用（一个指针）
python参数传递：传不可变对象（str、tuples）、可变对象（list、dict)
不定长参数：函数处理比当初声明时更多的参数
*args：接收任意数量的位置参数，打包为tuple
**kwargs：接收任意数量的关键字参数，打包为dict
可使用 * 或 ** 将序列或字典解包为参数
匿名函数：不使用def语句来定义，lambda只是一个表达式，封装有限逻辑，有自己的命名空间，不能访问自己参数列表之外或全局命令空间里的参数
lambda [arg1 [,arg2,.....argn]]:expression

装饰器：是一种函数，可以动态修改函数或类；本质就是接收函数作为输入返回新的包装后的函数的对象。
装饰器通过 @ 符号应用在函数定义之前
类装饰器是包含 __call__ 方法的类，接受一个函数作为参数，并返回一个新的函数

运行期检测到的错误为异常
异常捕捉可以使用 try/except 语句
try-finally无论是否发生异常都将执行最后的代码
使用raise 语句抛出一个指定的异常：raise [Exception [, args [, traceback]]]
预定义清理行为：一些对象定义了标准的清理行为，无论系统是否成功使用，不需要它时标准的清理就会执行
with open ("test.txt") as f:该文件总是会关闭

命名空间：从名称到对象的映射，大部分都是通过dict实现的，提供了在项目中避免名字冲突的一种方法
内置名称： Python 语言内置的名称
全局名称：模块中定义的名称
局部名称：函数中定义的名称
生命周期：取决于对象的作用域，如果对象执行完成，则该命名空间的生命周期就结束
作用域：Python程序可以直接访问命名空间的正文区域

使用 global 可以在函数中修改全局变量。
使用 nonlocal 可以在嵌套函数中修改外部函数的变量。

模块（Module）是一个包含Python定义和语句的文件，文件名就是模块名加上.py后缀
代码复用、命名空间管理、代码组织
包:管理 Python 模块命名空间的形式,采用"点模块名称"
在导入包时， sys.path 中的目录来寻找这个包中包含的子目录,只有包含 __init__.py 的文件才会被认作是一个包
from package import item对应的 item 既可以是包里面的子模块（子包），或者包里面定义的其他名称，比如函数，类或者变量(import把item当作包--->模块--->还没找到，抛出:exc:ImportError 异常)
import item.subitem.subsubitem ,除了最后一项，都必须是包，而最后一项则可以是模块/是包，但是不可以是类/函数/变量的名字。

内部排序：只使用内存
交换排序：冒泡排序、快速排序
插入排序：直接插入排序、希尔排序
选择排序：简单选择排序、堆排序
